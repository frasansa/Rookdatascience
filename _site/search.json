[
  {
    "objectID": "stats.html",
    "href": "stats.html",
    "title": "Statistics and Data Science",
    "section": "",
    "text": "In this section, you will find some tips on statistics and data science using R. For most of the entries we will use the functions, style and approaches of the tidyverse universe. In addition, I try to stick to the following conventions in the text:\n\nPackages should appear as hyperlinks to the package website.\nTable (tibble) names should be in bold.\nColumn/variable names should be in italics.\nCategory names and function arguments should be enclosed in single quotes ’ ’.\nName of functions() should be in console font.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Gantt chart with R\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\nData Visualization\n\n\n\n\n\n\n\n\n\nJune 25, 2024\n\n\nFrancisco Sánchez-Sáez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "stars.html",
    "href": "stars.html",
    "title": "Searching stars",
    "section": "",
    "text": "This section features Advent of Code (AoC) challenges using R. The AoC is a series of small programming puzzles for a variety of skill sets and skill levels in any programming language. The challenges are published daily and are a great way to learn a new programming language or to learn new concepts in a familiar language. The challenges are available at https://adventofcode.com. The AoC is running from 2015 to the present and consists of two-part puzzles released every day from 1 to 25 December. For the two puzzles of each day, the input is the same.\nFor most of the challenges we will use the functions, style and approaches of the tidyverse universe. In addition, I try to stick to the following conventions in the text:\n\nPackages should appear as hyperlinks to the package website.\nTable (tibble) names should be in bold.\nColumn/variable names should be in italics.\nCategory names and function arguments should be enclosed in single quotes ’ ’.\nName of functions() should be in console font.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvent of Code Setup\n\n\n\n\n\n\nSetup\n\n\n\n\n\n\n\n\n\nJune 26, 2024\n\n\nFrancisco Sánchez-Sáez\n\n\n\n\n\n\n\n\n\n\n\n\nAdvent of Code. 2015-01\n\n\n\n\n\n\nEasy\n\n\n\n\n\n\n\n\n\nJune 26, 2024\n\n\nFrancisco Sánchez-Sáez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "stars/AoC_0.html",
    "href": "stars/AoC_0.html",
    "title": "Advent of Code Setup",
    "section": "",
    "text": "Introduction\nIn the Advent of Code (AoC) puzzles, the puzzle input is different for each user. In this entry, we will set up our session to load the input through our R Session. The instructions and functions are inspired by the https://github.com/botan/aocr?tab=readme-ov-file and https://github.com/dgrtwo/adventdrob/blob/main/R/input.R repositories.\n\n\nLoad packages and secrets.R File\nWe will use the httr2 package to get the inputs. First of all, we need to get the session information. We need to do the following steps:\n\nLog in to https://adventofcode.com/ using your preferred web browser.\nPress F12 or right click on the web page and click “Inspect” to open the developer console.\nGo the Network tab and reload the page.\nClick on the “Advent of Code” request at the top left of the screen.\nGo to the “Cookie” tab under the request” “Headers”.\nYou will find your cookie in session=. The cookie session is like a password, so you don’t want to put it with the code, that could be shown to other people so you need to keep it secret. The main options are to store it in a .Renviron file, which will be ready to load every time you start a session of R on this computer, or in a separate file (e.g. “secrets.R”).\nCopy and paste this cookie session into your .Renviron as AOC_SESSION=. If you have any trouble with finding your .Renviron file, you can use usethis::edit_r_environ(). Restart R session.\n\n\n# Load packages--------------------------------------------------------------\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr2)\n# Copy the cookie session and paste it into .Renviron\n# usethis::edit_r_environ()\n\n# Alternatively source secrets.R\n# source(\"..\", \"..\", \"secrets.R\")\n\n\n\nConfiguration of the session\nOnce we have stored the cookie session we create a function that allows us to retrieve the input selecting the year and the day.\n\n# Create a function to read the inputs---------------------------------------\nread_aoc_input &lt;- function(\n                  year,\n                  day ,\n                  verbose = TRUE,\n                  open_file = FALSE) {\n  \n  session &lt;- paste0(\"session=\", Sys.getenv(\"AOC_SESSION\"))\n  if (session == \"session=\") {\n    rlang::abort(c(\n      \"AOC_SESSION not found, please set the session in .Renviron or in secrets.R\",\n    ))\n  }\n  \n  url &lt;- paste0(\n    \"https://adventofcode.com/\",\n    year,\n    \"/day/\",\n    day,\n    \"/input\"\n  )\n\n  if (nchar(day) == 1) day &lt;- paste0(0, day)\n  req &lt;- httr2::request(url)\n  req &lt;- httr2::req_headers(req, cookie = session)\n  response &lt;- httr2::req_perform(req)\n  if (resp_status(response) == 200) {\n  # Get the content of the response\n  puzzle_input &lt;- resp_body_string(response)\n  # Print the puzzle input\n} else {\n  # Print debug information about the response\n  cat(\"Failed to fetch the puzzle input. Status code:\", resp_status(response), \"\\n\")\n  cat(\"Response Headers:\\n\")\n  print(response$headers)\n  cat(\"Response Body:\\n\")\n  print(resp_body_string(response))\n}\n}\n\n\n# Check the function to read the inputs--------------------------------------\ninput &lt;- read_aoc_input(year = 2015, day = 1)\n\n\n\nConvert into a working format\n\n# Convert the input to a working formats--------------------------------------\ninput_lines &lt;- str_split(input, \"\\n\")[[1]]\ninput_tibble &lt;- tibble(x = input_lines)\n\n\n\nStart the search\nNow that we have everything ready, we can start searching the stars. I’m not going to post the solutions in chronological order, but in order of difficulty, so first I will post 2015 day 1, then 2016 day 1, …, until 2023 day 1. Then the days 2 and so on. Stay tuned!"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Two-page CV",
    "section": "",
    "text": "Download current CV"
  },
  {
    "objectID": "chess/chess_1.html",
    "href": "chess/chess_1.html",
    "title": "Chess Problem 1",
    "section": "",
    "text": "Problem 1\nWhite to move.\n\n\n\n\n\n\n\n\n\nShow the solution\n\n\n\n\n1.Bxh6 gxh6 2.Qxh6 +-"
  },
  {
    "objectID": "chess.html",
    "href": "chess.html",
    "title": "Chess",
    "section": "",
    "text": "Welcome to the Chess Problems section! Here you will find various chess problems to solve. The diagrams are generated using rchess package (https://github.com/jbkunst/rchess).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChess Problem 1\n\n\n\n\n\n\nTactics\n\n\n\n\n\n\n\n\n\nJune 26, 2024\n\n\nFrancisco Sánchez-Sáez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rookdatascientist",
    "section": "",
    "text": "Rook Data Scientist: a website about R, data, statistics and chess.\n\n\n\n“Rooks belong on open files” - Popular chess wisdom."
  },
  {
    "objectID": "stars/AoC_2015_01.html",
    "href": "stars/AoC_2015_01.html",
    "title": "Advent of Code. 2015-01",
    "section": "",
    "text": "The puzzle’s instructions could be found in: https://adventofcode.com/2015/day/1\n\n\nFirst, we retrieve the input of the day (see Advent of Code Setup).\n\n# Load packages--------------------------------------------------------------\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr2)\n\n\n# Obtain the inputs--------------------------------------\ninput &lt;- read_aoc_input(year = 2015, day = 1)\ninput_lines &lt;- str_split(input, \"\\n\")[[1]]\ninput_tibble &lt;- tibble(x = input_lines)\n\n\n\n\nSanta was hoping for a white Christmas, but his weather machine’s “snow” function is powered by stars, and he’s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere’s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can’t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\n\nTo what floor do the instructions take Santa?\n\n\nWe can extract the number of “C” symbols using str_extract_all and check the total number of elements of the list using the lengths() function.\n\n\n\n\n\n\nNote\n\n\n\nNote that in order to retrieve the “(” and “)” characters, we need to escape them using “\\\\” characters This is necessary as “(” and “)” are part of the regex instructions\n\n\n\n# Obtain the number of \"(\" and the number of \")\"-----------------------------\nup &lt;- input_lines |&gt; str_extract_all(\"\\\\(\") |&gt; lengths()\ndown &lt;- input_lines |&gt; str_extract_all(\"\\\\)\") |&gt; lengths()\nup - down\n\n[1] 280\n\n\n\n\n\n\nNow, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n\n) causes him to enter the basement at character position 1.\n()()) causes him to enter the basement at character position 5.\n\nWhat is the position of the character that causes Santa to first enter the basement?\n\n\nWe need to make a counter that starts from the beginning. We define floor as 0, then we create a “for loop” (yes a for loop: God forgive us) where we add a floor when we find “(” and we subtract a floor when we find “)”. We use the nchar() function to count the number of a characters in our input string. We use the seq_len() function, which allows us to set elegantly the condition of the loop, and the str_sub()function to get each character of the string. Finally, we use the return() function to exit the loop and return the value of interest, i.\n\n# Obtain the instruction to strives to floor -1------------------------------\nfloor &lt;- 0\nfor(i in seq_len(nchar(input_lines))){\nif(input_lines |&gt; str_sub(i,i) == \"(\") floor &lt;- floor + 1\nelse floor &lt;- floor -1\nif(floor == -1){return(i)}\n} \n\ni\n\n[1] 1797"
  },
  {
    "objectID": "stars/AoC_2015_01.html#retrieve-the-input",
    "href": "stars/AoC_2015_01.html#retrieve-the-input",
    "title": "Advent of Code. 2015-01",
    "section": "",
    "text": "First, we retrieve the input of the day (see Advent of Code Setup).\n\n# Load packages--------------------------------------------------------------\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr2)\n\n\n# Obtain the inputs--------------------------------------\ninput &lt;- read_aoc_input(year = 2015, day = 1)\ninput_lines &lt;- str_split(input, \"\\n\")[[1]]\ninput_tibble &lt;- tibble(x = input_lines)"
  },
  {
    "objectID": "stars/AoC_2015_01.html#part-1",
    "href": "stars/AoC_2015_01.html#part-1",
    "title": "Advent of Code. 2015-01",
    "section": "",
    "text": "Santa was hoping for a white Christmas, but his weather machine’s “snow” function is powered by stars, and he’s fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.\nCollect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\nHere’s an easy puzzle to warm you up.\nSanta is trying to deliver presents in a large apartment building, but he can’t find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.\nAn opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.\nThe apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.\nFor example:\n\n(()) and ()() both result in floor 0.\n((( and (()(()( both result in floor 3.\n))((((( also results in floor 3.\n()) and ))( both result in floor -1 (the first basement level).\n))) and )())()) both result in floor -3.\n\nTo what floor do the instructions take Santa?\n\n\nWe can extract the number of “C” symbols using str_extract_all and check the total number of elements of the list using the lengths() function.\n\n\n\n\n\n\nNote\n\n\n\nNote that in order to retrieve the “(” and “)” characters, we need to escape them using “\\\\” characters This is necessary as “(” and “)” are part of the regex instructions\n\n\n\n# Obtain the number of \"(\" and the number of \")\"-----------------------------\nup &lt;- input_lines |&gt; str_extract_all(\"\\\\(\") |&gt; lengths()\ndown &lt;- input_lines |&gt; str_extract_all(\"\\\\)\") |&gt; lengths()\nup - down\n\n[1] 280"
  },
  {
    "objectID": "stars/AoC_2015_01.html#part-2",
    "href": "stars/AoC_2015_01.html#part-2",
    "title": "Advent of Code. 2015-01",
    "section": "",
    "text": "Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.\nFor example:\n\n) causes him to enter the basement at character position 1.\n()()) causes him to enter the basement at character position 5.\n\nWhat is the position of the character that causes Santa to first enter the basement?\n\n\nWe need to make a counter that starts from the beginning. We define floor as 0, then we create a “for loop” (yes a for loop: God forgive us) where we add a floor when we find “(” and we subtract a floor when we find “)”. We use the nchar() function to count the number of a characters in our input string. We use the seq_len() function, which allows us to set elegantly the condition of the loop, and the str_sub()function to get each character of the string. Finally, we use the return() function to exit the loop and return the value of interest, i.\n\n# Obtain the instruction to strives to floor -1------------------------------\nfloor &lt;- 0\nfor(i in seq_len(nchar(input_lines))){\nif(input_lines |&gt; str_sub(i,i) == \"(\") floor &lt;- floor + 1\nelse floor &lt;- floor -1\nif(floor == -1){return(i)}\n} \n\ni\n\n[1] 1797"
  },
  {
    "objectID": "stats/gantt_chart.html",
    "href": "stats/gantt_chart.html",
    "title": "Creating a Gantt chart with R",
    "section": "",
    "text": "Introduction\nIn this entry I will show you how to create a Gantt chart in R using the ggplot2 package. Gantt charts are a great way to visualise project schedules. Although there are several packages that advocate building Gantt charts in R, I have decided that the easiest and most flexible way is to build them using the ggplot2 package. So, here is a step-by-step guide.\n\n\nInstall and load the required packages\nFirst, make sure you have the ggplot2, dplyr, tidyr, lubridate, and forcats packages installed. A shortcut for using these packages is to directly install and load the tidyverse bunch of packages.\n\n# Load the libraries---------------------------------------------------------\n# install the package (uncomment if the package is not installed)\n# install.packages(\"tidyverse\")\n\n# load the ggplot2 package\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nPrepare your data\nPrepare your data in a tibble. Your data should include columns for the task name, start date and end date. To define dates we use the ymd() function from the lubridate package, which allows you to define Dates easily as strings.\n\n# Create the tasks-----------------------------------------------------------\ntasks &lt;- tibble(\n  task = c(\n  # task 1  \n  \"The first task of my project\", \n  # task 2\n  \"A super important task\", \n  # task 3\n  \"Another super important task\",\n  # task 4\n  \"A 'in parallel' task\",\n  # task 5\n  \"The other 'in parallel' task\", \n  # task 6\n  \"The last task of my project\"),\n  start = c(\n    # task 1  \n    ymd(\"2024-06-25\"),\n    # task 2\n    ymd(\"2024-07-15\"),\n    # task 3 \n    ymd(\"2024-08-26\"),\n    # task 4 \n    ymd(\"2024-11-08\"),\n    # task 5\n    ymd(\"2024-11-08\"),\n    # task 6\n    ymd(\"2025-02-01\")\n    ),\n  end = c(\n    # task 1\n    ymd(\"2024-07-05\"),\n    # task 2\n    ymd(\"2024-08-16\"),\n    # task 3\n    ymd(\"2024-10-31\"),\n    # task 4\n    ymd(\"2024-12-20\"),\n    # task 5\n    ymd(\"2025-01-31\"),\n    # task 6\n    ymd(\"2025-03-31\")\n    ))\n\ntasks\n\n# A tibble: 6 × 3\n  task                         start      end       \n  &lt;chr&gt;                        &lt;date&gt;     &lt;date&gt;    \n1 The first task of my project 2024-06-25 2024-07-05\n2 A super important task       2024-07-15 2024-08-16\n3 Another super important task 2024-08-26 2024-10-31\n4 A 'in parallel' task         2024-11-08 2024-12-20\n5 The other 'in parallel' task 2024-11-08 2025-01-31\n6 The last task of my project  2025-02-01 2025-03-31\n\n\nOnce the tasks are created, we pivot the data longer to feed the ggplot() function in a convenient way. pivot_longer() is a function from the tidyr package which allow to convert a tibble from wide to long format.\n\n# Pivot longer the tasks-------------------------------------------------------\ntasks_long &lt;- tasks |&gt; \n  pivot_longer(c(start, end), names_to = \"type\", values_to = \"date\")\n\ntasks_long\n\n# A tibble: 12 × 3\n   task                         type  date      \n   &lt;chr&gt;                        &lt;chr&gt; &lt;date&gt;    \n 1 The first task of my project start 2024-06-25\n 2 The first task of my project end   2024-07-05\n 3 A super important task       start 2024-07-15\n 4 A super important task       end   2024-08-16\n 5 Another super important task start 2024-08-26\n 6 Another super important task end   2024-10-31\n 7 A 'in parallel' task         start 2024-11-08\n 8 A 'in parallel' task         end   2024-12-20\n 9 The other 'in parallel' task start 2024-11-08\n10 The other 'in parallel' task end   2025-01-31\n11 The last task of my project  start 2025-02-01\n12 The last task of my project  end   2025-03-31\n\n\n\n\nPlot the diagram\nOnce we have the tasks in a convenient format we can create the chart First, we define the language of the dates that will be appear in the month names of the chart\n\n# Create the Gantt chart-----------------------------------------------------\n# set the language of the months\n# in english\nSys.setlocale(\"LC_TIME\", \"en_EN\")\n\n[1] \"en_EN\"\n\n# in spanish\n# Sys.setlocale(\"LC_TIME\", \"es_ES\")\n\nNow we go for the ggplot(). With ggplot2, you start a plot with the ggplot() function. It creates a coordinate system to which you can add layers to. The first argument of ggplot() is the dataset to use in the graph. So tasks_long |&gt; ggplot() creates an empty graph. To complete the graph by adding one or more layers to ggplot(). The geom_line() function adds a layer of lines to the plot. Every geom function in ggplot2 takes a mapping argument. This defines how variables in your dataset are mapped to visual properties. The mapping argument is always paired with aes(), and the ‘x’ and ‘y’ arguments of aes() specify which variables to map to the x and y axes.\nTo build our Gantt chart, we use geom_line() to define the tasks. We have each task twice in the tasks_long tibble, with two different dates. So we define the argument ‘y’ with the task variable and the argument ‘x’ with the date variable.\n\n\n\n\n\n\nNote\n\n\n\nNote that the ‘size’ and ‘color’ arguments are outside of the aes() function, so these arguments don’t depend on the data and are fixed.\n\n\nWe use the fct_inorder() and fct_rev() functions from the forcats package to set the order of the factors. Specifically, with fct_inorder we define the order of the tasks in the same order as they appear in the tasks_long tibble. Then with the fct_rev() we start from top to bottom to display the tasks.\nThen, we use geom_vline()to definethe current date with a vertical line.\nNext, we define the axis of the dates. We use the scale_x_date() function to define the x axis. Setting the limits allows us to centre the breaks in the graph. With the ‘date_breaks’ argument we can adjust the frequency of the breaks according to our time frame (n weeks, n months, n years, etc.) and with the ‘date_labels’ argument we can specify how the date appears in the plot.\nFinally, we make the last adjustments of the plot. We use the labs() function to set the title and the names of the x and y axes. The theme_bw() function sets a minimalist theme, with the ‘base_size’ argument we set the size of all the texts in the plot, and with theme(plot.title = element_text(hjust = 0.5)) we centre the title of the plot.\n\n# Do the plot----------------------------------------------------------------\ntasks_long |&gt;  ggplot() +\n  geom_line(mapping = aes(y = task |&gt; fct_inorder() |&gt; fct_rev(), x = date), \n            size = 10, color = \"purple\") +\n  geom_vline(xintercept = Sys.Date(), colour=\"red\", \n             linetype=\"dashed\",\n             size = 1) +\n  scale_x_date(\n  limits = c(ymd(\"2024-05-20\"), ymd(\"2025-04-01\")),\n  date_breaks = \"2 month\", date_labels = \"%b %Y\") +\n  labs(title = \"Gantt Chart\",\n       x = \"Task\",\n       y = \"Date\") +\n  theme_bw(base_size = 16) +\n   theme(plot.title = element_text(hjust = 0.5))"
  }
]